"# Implementation of the BFD with randomization and balance.\n\nimport time\nimport random\nimport math\nimport copy\nimport sswing_scheduler as SS\n\ndef make_random_volunteers(num_of_volunteers, hour_range):\n    V = []\n    for x in xrange(1, num_of_volunteers+1):\n        name = \"Volunteer \" + str(x)\n        capacity = random.randint(hour_range[0], hour_range[1])\n        volunteer = SS.Volunteer(name, capacity)\n        available_start = random.randint(0,18)\n        volunteer.add_job(SS.Job(\"UNAVAILABLE\", (0, available_start)))\n        volunteer.add_job(SS.Job(\"UNAVAILABLE\", (available_start+capacity, 24)))\n        V.append(volunteer)\n    return V\n\ndef make_random_jobs(num_of_jobs):\n    J = []\n    for y in xrange(1, 31):\n        name = \"Job \" + str(y)\n        time_interval = SS.rand_time_interval(0, 21, random.randint(1,3))\n        job = SS.Job(name, time_interval)\n        J.append(job)\n    return J\n\n\ndef assign_jobs(jobs, volunteers):\n    unassigned_jobs = []\n    J = sorted(jobs)\n    V = volunteers\n\n    while len(J) > 0:\n        job = J.pop(0)\n        job_assigned = False\n        V = sorted(V)\n\n        for v in V:\n            if v.can_take_job(job):\n                v.add_job(job)\n                job_assigned = True\n                break\n\n        if not job_assigned:\n            unassigned_jobs.append(job)\n\n    return (V, unassigned_jobs)\n\n\nvolunteers = make_random_volunteers(60, (2,6))\njobs = make_random_jobs(30)\n\nfor i in xrange(5):\n    factor = 10**i\n    min_vol_list = []\n    best_vol_schedule = []\n    smallest = 100\n    biggest = 0\n\n    start = time.time()\n    print \"Running %s...\" % factor\n    for x in xrange(factor):\n        j = jobs[:]\n        V, uj = assign_jobs(j, volunteers)\n\n        if len(uj) == 0:\n            min_v = sum([1 for x in V if x.is_used])\n            if min_v > biggest:\n                biggest = min_v\n            if min_v < smallest:\n                smallest = min_v\n            if len(best_vol_schedule) == 0 or min_v < sum([1 for x in best_vol_schedule if x.is_used]):\n                best_vol_schedule = copy.deepcopy(V)\n\n        map(lambda x: x.clear_all(), volunteers)\n        random.shuffle(volunteers)\n\n    end = time.time()\n\n    print \"DONE in %s\" % (end-start)\n    print \"Smallest: %s\" % smallest\n    print \"Biggest: %s\" % biggest\n    print \"\\n\"\n\n    #SS.show_schedule(best_vol_schedule)\n\n\n# Now need to find an optimal way to balance the schedule\n\n# OLD algo stuff...\n\n# This approach probably won't work... Not sure how to generate undominated sets with jobs...\n# simply generating subsets of 30 jobs blows the stack...\n#\n# Pseudo-code for Korf Algorithm:\n#\n# Compute BFD solution.\n# Compute Lower-Bound with the wasted space method (*)\n# If BFD Sol == Lower Bound then Stop -> return solution\n# Else set BFD sol as current best complete solution\n#      and start branch&bound search for strictly better solutions\n#      pruning all partial solutions >= current best complete solution\n#\n# Branch and bound steps:\n# Order elements in decreasing order\n# For e in ordered_elements:\n#   Find bin containing e\n#   generate all undominated completions of bin (**)\n#   if 0 or 1 undominated completion:\n#     complete bin this way\n#   else if more than 1 undominated completion:\n#     order completions descending by sum\n#     consider largest first, leave rest as branches\n#     when complete solution is found and is better than current, update current best\n#       -compute lower bound on partial solution (***)\n#       - if worse than current best, prune partial solution\n#\n#\n# (*) generating undominating terms:\n# Generate subsets of feasible completion\n# Test them for dominance\n"