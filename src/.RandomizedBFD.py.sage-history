"import sys\nimport random\nimport copy\nimport Work as SS\n\n\ndef rand_time_interval(a_min, a_max, a_length):\n    start = random.randint(a_min, a_max - a_length)\n    return (start, start+a_length)\n\n\ndef show_schedule(volunteers):\n    for v in volunteers:\n        if v.is_used:\n            v.print_schedule()\n\n\ndef make_random_volunteers(num_of_volunteers, hour_range):\n    V = []\n    for x in xrange(1, num_of_volunteers+1):\n        name = \"Volunteer \" + str(x)\n        capacity = random.randint(hour_range[0], hour_range[1])\n        volunteer = SS.Volunteer(name, capacity)\n        available_start = random.randint(0,18)\n        volunteer.add_job(SS.JobShift(\"UNAVAILABLE\", (0, available_start)))\n        volunteer.add_job(SS.JobShift(\"UNAVAILABLE\", (available_start+capacity, 24)))\n        V.append(volunteer)\n    return V\n\n\ndef make_random_jobs(num_of_jobs):\n    J = []\n    for y in xrange(1, 31):\n        name = \"Shift \" + str(y)\n        time_interval = rand_time_interval(0, 21, random.randint(1,3))\n        job = SS.JobShift(name, time_interval)\n        J.append(job)\n    return J\n\n\ndef assign_jobs(jobs, volunteers):\n    unassigned_jobs = []\n    current_jobs = sorted(jobs)\n    current_volunteers = volunteers\n\n    while len(current_jobs) > 0:\n        job = current_jobs.pop(0)\n        current_volunteers = sorted(current_volunteers)\n        job_assigned = False\n\n        for volunteer in current_volunteers:\n            if volunteer.can_take_job(job):\n                volunteer.add_job(job)\n                job_assigned = True\n                break\n\n        if not job_assigned:\n            unassigned_jobs.append(job)\n\n    return (current_volunteers, unassigned_jobs)\n\n\nvolunteers = make_random_volunteers(60, (2,6))\njobs = make_random_jobs(30)\n\ntotal_job_hours = sum([j.length for j in jobs])\navg_vol_capacity = sum([v.capacity for v in volunteers])/float(60)\nestimated_lower_bound = int((total_job_hours/avg_vol_capacity)+1)\n\ncurrent_best_schedule = []\nmin_volunteers_needed = 60\n\nprint \"Estimated Lower Bound: %s...\" % estimated_lower_bound\nwhile(min_volunteers_needed > estimated_lower_bound):\n    try:\n        volunteers, unassigned_jobs = assign_jobs(jobs, volunteers)\n\n        if len(unassigned_jobs) == 0:\n            current_min = sum([1 for x in volunteers if x.is_used])\n            if current_min < min_volunteers_needed:\n                min_volunteers_needed = current_min\n                current_best_schedule = copy.deepcopy(volunteers)\n                print \"Current min volunteers needed: %s\" % min_volunteers_needed\n\n        map(lambda x: x.clear_all(), volunteers)\n        random.shuffle(volunteers)\n\n    except KeyboardInterrupt:\n        print \"Terminating...\\n\\n\"\n        if len(unassigned_jobs) == 0:\n            print \"Min # of volunteers found so far: %s\" % min_volunteers_needed\n            print \"Schedule: \"\n            show_schedule(current_best_schedule)\n            print \"\\n\"\n        else:\n            print \"Not able to find feasible solution\"\n            print \"Unassigned jobs: %s\" % unassigned_jobs\n            print \"Current best schedule: \"\n            show_schedule(volunteers)\n        sys.exit()\n\nprint \"Finished with optimal (%s) number of volunteers.\" % min_volunteers_needed\nshow_schedule(current_best_schedule)\n"