"import sys\nimport random\nimport copy\nimport Work as SS\n\n\ndef rand_time_interval(a_min, a_max, a_length):\n    start = random.randint(a_min, a_max - a_length)\n    return (start, start+a_length)\n\n\ndef show_schedule(volunteers):\n    for v in volunteers:\n        if v.is_used:\n            v.print_schedule()\n\n\ndef make_random_volunteers(num_of_volunteers, capacity_range):\n    V = []\n    for x in xrange(1, num_of_volunteers+1):\n        name = \"Volunteer \" + str(x)\n        capacity = random.randint(capacity_range[0], capacity_range[1])\n        volunteer = SS.Volunteer(name, capacity)\n        available_start = random.randint(0, 24-capacity)\n        volunteer.add_job(SS.JobShift(\"UNAVAILABLE\", (0, available_start), -1))\n        volunteer.add_job(SS.JobShift(\"UNAVAILABLE\", (available_start+capacity, 24), -1))\n        V.append(volunteer)\n    return V\n\n\ndef make_random_jobs(num_of_jobs):\n    J = []\n    for x in xrange(1, num_of_jobs+1):\n        id = x-1\n        num_of_shifts = random.randint(1,6)\n        start_time = random.randint(0, 21-num_of_shifts)\n        for y in xrange(1, num_of_shifts+1):\n            name = \"Shift \" + str(x) + \".\" + str(y)\n            time_interval = (start_time+y-1, start_time+y)\n            job = SS.JobShift(name, time_interval, id)\n            J.append(job)\n    return J\n\n# BFD Algo: put largest item into bin with most stuff\ndef assign_jobs(jobs, volunteers):\n    unassigned_jobs = []\n    current_jobs = sorted(jobs)\n    current_volunteers = volunteers\n\n    while len(current_jobs) > 0:\n        job = current_jobs.pop(0)\n        current_volunteers = sorted(current_volunteers) # This makes it a BFD instead of an FFD algo\n        job_assigned = False\n\n        for volunteer in current_volunteers:\n            if volunteer.can_take_job(job):\n                volunteer.add_job(job)\n                job_assigned = True\n                break\n\n        if not job_assigned:\n            unassigned_jobs.append(job)\n\n    return (current_volunteers, unassigned_jobs)\n\n\nNUM_OF_JOBS = 15\nNUM_OF_VOLUNTEERS = 60\nvolunteers = make_random_volunteers(NUM_OF_VOLUNTEERS, (2,6))\njobs = make_random_jobs(NUM_OF_JOBS)\n\n# estimating lower bound by dividing sum of shifts by average volunteer capacity\ntotal_job_hours = sum([j.length for j in jobs])\navg_vol_capacity = sum([v.capacity for v in volunteers])/float(len(volunteers))\nestimated_lower_bound = int((total_job_hours/avg_vol_capacity)+1)\n\ncurrent_best_schedule = []\nmin_volunteers_needed = 60\n\nprint \"Estimated Lower Bound: %s...\" % estimated_lower_bound\n\n# Here we start randomizing the volunteer set to get different solutions\n# we keep track of the smallest solution and store it\n# we can choose to terminate before the optimal sol is found\n# we will either get the current most optimal solution\n# or an unfeasible, partial solution, with a list of anassignable jobs.\nwhile(min_volunteers_needed > estimated_lower_bound):\n    try:\n        volunteers, unassigned_jobs = assign_jobs(jobs, volunteers)\n\n        if len(unassigned_jobs) == 0:\n            current_min = sum([1 for x in volunteers if x.is_used])\n            if current_min < min_volunteers_needed:\n                min_volunteers_needed = current_min\n                current_best_schedule = copy.deepcopy(volunteers)\n                print \"Current min volunteers needed: %s\" % min_volunteers_needed\n\n        map(lambda x: x.clear_all(), volunteers)\n        random.shuffle(volunteers)\n\n    except KeyboardInterrupt:\n        print \"Terminating...\\n\\n\"\n        if len(unassigned_jobs) == 0:\n            print \"Min # of volunteers found so far: %s\" % min_volunteers_needed\n            print \"Schedule: \"\n            show_schedule(current_best_schedule)\n            print \"\\n\"\n        else:\n            print \"Not able to find feasible solution\"\n            print \"Unassigned jobs: %s\" % unassigned_jobs\n            print \"Current best schedule: \"\n            show_schedule(volunteers)\n        sys.exit()\n\nprint \"Finished with optimal (%s) number of volunteers.\" % min_volunteers_needed\nshow_schedule(current_best_schedule)\n"
{"patch":[[[[0,"S = "],[-1,"15"],[1,"3"],[0,"\nNUM"]],2005,2005,10,9]],"time":1425300366702}
{"patch":[[[[0,"JOBS = 3"],[1,"0"],[0,"\nNUM_OF_"]],2002,2002,16,17]],"time":1425300365953}
{"patch":[[[[0,"S = "],[-1,"30"],[1,"1"],[0,"\nNUM"]],2005,2005,10,9]],"time":1425300334494}
{"patch":[[[[0,"JOBS = 1"],[1,"5"],[0,"\nNUM_OF_"]],2002,2002,16,17]],"time":1425300333774}
{"patch":[[[[0,"EERS = 6"],[-1,"0"],[0,"\nvolunte"]],2025,2025,17,16]],"time":1425300332866}
{"patch":[[[[0,"TEERS = "],[-1,"6"],[0,"\nvolunte"]],2024,2024,17,16]],"time":1425300331880}
{"patch":[[[[0,"TEERS = "],[1,"2"],[0,"\nvolunte"]],2024,2024,16,17]],"time":1425300331070}
{"patch":[[[[0,"EERS = 2"],[1,"0"],[0,"\nvolunte"]],2025,2025,16,17]],"time":1425300330290}
{"patch":[[[[0,"EERS = 2"],[-1,"0"],[0,"\nvolunte"]],2025,2025,17,16]],"time":1425300271706}
{"patch":[[[[0,"TEERS = "],[-1,"2"],[0,"\nvolunte"]],2024,2024,17,16]],"time":1425300270770}
{"patch":[[[[0,"TEERS = "],[1,"6"],[0,"\nvolunte"]],2024,2024,16,17]],"time":1425300270003}
{"patch":[[[[0,"EERS = 6"],[1,"0"],[0,"\nvolunte"]],2025,2025,16,17]],"time":1425300269052}
{"patch":[[[[0,"TEERS = "],[-1,"60"],[0,"\nvolunte"]],2024,2024,18,16]],"time":1425300232230}
{"patch":[[[[0,"TEERS = "],[1,"3"],[0,"\nvolunte"]],2024,2024,16,17]],"time":1425300231470}
{"patch":[[[[0,"S = "],[-1,"3"],[0,"\nvol"]],2028,2028,9,8]],"time":1425300230675}
{"patch":[[[[0,"TEERS = "],[1,"120"],[0,"\nvolunte"]],2024,2024,16,19]],"time":1425300229942}
{"patch":[[[[0,"S = "],[-1,"15"],[1,"3"],[0,"\nNUM"]],2005,2005,10,9]],"time":1425300228401}
{"patch":[[[[0,"JOBS = 3"],[1,"0"],[0,"\nNUM_OF_"]],2002,2002,16,17]],"time":1425300227694}
{"patch":[[[[0,"S = "],[-1,"120"],[0,"\nvol"]],2028,2028,11,8]],"time":1425300218836}
{"patch":[[[[0,"TEERS = "],[1,"8"],[0,"\nvolunte"]],2024,2024,16,17]],"time":1425300218114}
{"patch":[[[[0,"EERS = 8"],[1,"0"],[0,"\nvolunte"]],2025,2025,16,17]],"time":1425300217318}
{"patch":[[[[0,"S = "],[-1,"80"],[0,"\nvol"]],2028,2028,10,8]],"time":1425300195710}
{"patch":[[[[0,"TEERS = "],[1,"60"],[0,"\nvolunte"]],2024,2024,16,18]],"time":1425300194164}
{"patch":[[[[0,"JOBS = 3"],[-1,"0"],[0,"\nNUM_OF_"]],2002,2002,17,16]],"time":1425300192052}
{"patch":[[[[0,"S = "],[-1,"3"],[0,"\nNUM"]],2005,2005,9,8]],"time":1425300191118}
{"patch":[[[[0,"_JOBS = "],[1,"1"],[0,"\nNUM_OF_"]],2001,2001,16,17]],"time":1425300190264}
{"patch":[[[[0,"nteers, "],[-1,"capacity"],[1,"hour"],[0,"_range):"]],343,343,24,20],[[[0,"randint("],[-1,"capacity"],[1,"hour"],[0,"_range[0"]],483,483,24,20],[[[0,"nge[0], "],[-1,"capacity"],[1,"hour"],[0,"_range[1"]],498,498,24,20],[[[0,"t(0,"],[-1," 24-capacity"],[1,"18"],[0,")\n  "]],609,609,20,10],[[[0,"e_start)"],[-1,", -1"],[0,"))\n     "]],682,682,20,16],[[[0," 24)"],[-1,", -1"],[0,"))\n "]],772,772,12,8],[[[0," []\n"],[-1,"    for x in xrange(1, num_of_jobs+1):\n        id = x-1\n        num_of_shifts = random.randint(1,6)\n        start_time = random.randint(0, 21-num_of_shifts)\n    "],[0,"    "]],864,864,169,8],[[[0,"(1, "],[-1,"num_of_shifts+"],[1,"3"],[0,"1):\n"]],887,887,22,9],[[[0,"1):\n        "],[-1,"   "],[-1," "],[0,"name = \"Shif"]],892,892,28,24],[[[0,"str("],[-1,"x) + \".\" + str(y)\n    "],[1,"y)\n"],[0,"    "]],922,922,30,11],[[[0,"l = "],[-1,"(start_time+y-1, start_time+y)\n    "],[1,"rand_time_interval(0, 21, random.randint(1,3))\n"],[0,"    "]],949,949,43,55],[[[0,"rval"],[-1,", id"],[0,")\n  "]],1041,1041,12,8],[[[0,"        "],[-1," "],[-1,"   "],[0,"J.append"]],1047,1047,20,16],[[[0," J\n\n"],[-1,"# BFD Algo: put largest item into bin with most stuff"],[0,"\ndef"]],1079,1079,61,8],[[[0,"ers)"],[-1," # This makes it a BFD instead of an FFD algo"],[0,""],[1,""],[0,"\n   "]],1331,1331,53,8],[[[0,")\n\n\n"],[-1,"NUM_OF_JOBS = 1\nNUM_OF_VOLUNTEERS = 60\n"],[0,"volu"]],1670,1670,47,8],[[[0,"ers("],[-1,"NUM_OF_VOLUNTEERS"],[1,"60"],[0,", (2"]],1706,1706,25,10],[[[0,"obs("],[-1,"NUM_OF_JOBS)\n\n# estimating lower bound by dividing sum of shifts by average volunteer capacity"],[1,"30)\n"],[0,"\ntot"]],1741,1741,102,12],[[[0,"oat("],[-1,"len(volunteers)"],[1,"60"],[0,")\nes"]],1857,1857,23,10],[[[0,"ound"],[-1,"\n\n# Here we start randomizing the volunteer set to get different solutions\n# we keep track of the smallest solution and store it\n# we can choose to terminate before the optimal sol is found\n# we will either get the current most optimal solution\n# or an unfeasible, partial solution, with a list of anassignable jobs."],[0,"\nwhi"]],2043,2043,324,8]],"time":1425300189317}