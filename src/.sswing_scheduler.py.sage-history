"import random\n\n\nclass Volunteer:\n    def __init__(self, a_name=\"\", a_capacity=4):\n        self.name = a_name\n        self.jobs = []\n        self.capacity = a_capacity\n        self.current_capacity = 0\n        self.is_used = False\n\n    def __cmp__(self, other):\n        return -cmp(self.current_capacity, other.current_capacity)\n\n    def __repr__(self):\n        return self.name\n\n    def add_job(self, a_job):\n        self.jobs.append(a_job)\n        if not a_job.name.startswith(\"UNAVAILABLE\"):\n            self.current_capacity += a_job.length\n            self.is_used = True\n\n    def can_take_job(self, a_job):\n        for j in self.jobs:\n            if a_job.conflicts_with(j):\n                return False\n\n        if self.current_capacity + a_job.length > self.capacity:\n            return False\n\n        return True\n\n    def print_schedule(self):\n        self.jobs = sorted(self.jobs, key=lambda x: x.start)\n        print \"Name: %s :: Hours %s\" % (self.name, self.capacity)\n        for j in self.jobs:\n            print \"\\t%s :: %s - %s\" % (j.name, j.start, j.end)\n\n\nclass Job:\n    def __init__(self, a_name, a_time_interval):\n        self.name = a_name\n        self.start, self.end  = a_time_interval\n        self.interval = set(range(self.start, self.end+1))\n        self.length = self.end - self.start\n\n    def __cmp__(self, other):\n        return -cmp(self.length, other.length)\n\n    def __repr__(self):\n        return \"%s :: %s - %s\" % (self.name, self.start, self.end)\n\n    def conflicts_with(self, another_job):\n        return len(self.interval & another_job.interval) > 1\n\n\n# Helper Functions\ndef rand_time_interval(a_min, a_max):\n    a = random.randint(a_min, a_max-1)\n    # b = random.randint(a+1, a_max)\n    return (a, a+1)\n\ndef show_schedule(volunteers):\n    for v in volunteers:\n        if v.is_used:\n            v.print_schedule()\n"
{"patch":[[[[-1,"import random\n\n"],[1,"# Initial code for the scheduling algorith can go here.\n# We can refactor as needed.\n\nimport random\nimport Queue\nimport sswing_scheduler as SS\n\n# Object definitions"],[0,"\ncla"]],0,0,19,168],[[[0," = 0"],[-1,"\n        self.is_used = False"],[0,"\n\n  "]],345,345,37,8],[[[0,"    "],[-1,"if not a_job.name.startswith(\"UNAVAILABLE\""],[1,"self.current_capacity += a_job.length\n\n    def can_take_job(self, a_job"],[0,"):\n "]],565,565,50,79],[[[0,"b):\n        "],[-1,"   "],[1,"if"],[0," self.curren"]],639,639,27,26],[[[0,"rrent_capacity +"],[-1,"="],[0," a_job.length\n  "]],661,661,33,32],[[[0,"ngth"],[-1,"\n            self.is_used = True\n\n    def can_take_job(self, a_job):\n"],[1," > self.capacity:\n            return False\n        elif len(self.jobs) == 0:\n            return True\n        else:\n    "],[0,"    "]],686,686,77,127],[[[0,"j in self.jobs:\n"],[1,"    "],[0,"            if a"]],821,821,32,36],[[[0,"    "],[-1,"return False\n\n        if self.current_capacity + a_job.length > self.capacity:\n            return False\n\n"],[1,"    return False\n    "],[0,"    "]],893,893,113,29],[[[0,"val\n"],[-1,"        self.interval = set(range(self.start, self.end+1))\n"],[0,"    "]],1320,1320,67,8],[[[0,"    "],[-1,"return len(self.interval & another_job.interval) > 1\n\n\n# Helper Functions\ndef rand_time_interval(a_min, a_max):\n    a = random.randint(a_min, a_max-1)\n    # b = random.randint(a+1, a_max)\n    return (a, a+1)\n\ndef show_schedule(volunteers):\n    for v in volunteers:\n        if v.is_used:\n            v.print_schedule()"],[1,"if another_job.start == self.start or another_job.end == self.end:\n            return True\n        elif (self.start < another_job.start < self.end) or (self.start < another_job.end < self.end):\n            return True\n        else:\n            return False\n\n\n# test code\n\ndef rand_time_interval(a_min, a_max):\n    a = random.randint(a_min, a_max-1)\n    # b = random.randint(a+1, a_max)\n    return (a, a+1)\n\ndef show_schedule(volunteers):\n    for v in volunteers:\n        v.print_schedule()\n\nV = [SS.Volunteer(a_name=\"Volunteer \" + str(z), a_capacity=random.randint(2,6)) for z in xrange(1,61)]\nJ = sorted([SS.Job(\"Job \"+str(z), rand_time_interval(0,21)) for z in xrange(1,31)])\n\n\nunassigned_jobs = []\n# algorithm (greedy)\nwhile len(J) > 0:\n    j = J.pop(0)\n    curr_job_assigned = False\n    V = sorted(V)\n\n    for v in V:\n        if v.can_take_job(j):\n            v.add_job(j)\n            curr_job_assigned = True\n            break\n\n    if not curr_job_assigned:\n        unassigned_jobs.append(j)\n\n\nif len(unassigned_jobs) == 0:\n    min_v = sum([1 for x in V if len(x.jobs) != 0])\n    print min_v\nelse:\n    print \"There are unassigned jobs...\"\n    print unassigned_jobs"],[0,"\n"]],1586,1586,322,1174]],"time":1425249483092}
{"patch":[[[[0,"ed_jobs\n"],[1,"\n"]],2752,2752,8,9]],"time":1425195669151}
{"patch":[[[[0,"ed_jobs\n"],[-1,"\n"]],2752,2752,9,8]],"time":1425195667189}