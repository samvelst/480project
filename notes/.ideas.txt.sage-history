"Some ideas and solutions to our problem...\n\nThis looks like it can be modeled as the Bin Packing problem. This is a well known problem which is NP-hard.\n\nFor our problem:\n\nWe have a list of n jobs in a given day, each with a time interval and required skills.\n\nWe also have m volunteers. Each with time restrictions and skills.\n\nLet each volunteer be a bin, and each job an item to put into a bin.\n\nIf the job is outside of the volunteers time slot, the item is \"too heavy\" for that bin.\n\nIf the volunteer is given a job that conflicts with a current job, that bin is made \"too heavy\".\n\nWe want to find B <= m, which is the minimum number of volunteers needed to cover all jobs.\n\nHere we assume that each job that needs multiple people will be listed as multiple jobs.\n\n\nWe can probably find B, but how do we produce a schedule with it???\n\n\nsome algorithms:\n\nFirst fit algorithm - provides a fast O(nlogn) but often non-optimal solution. Can be made more effective by sorting the list of elements to be packed. (Does this make sense for our problem?) However, this still doesn't guarantee an optimal solution. BUT, there exists one ordering of elements which will produce an optimal solution with this algorithm (maybe try randomized approach?).\n\nWhen items that are placed together have a decreased combined size, this variant is called the VM packing problem. So maybe if we have something like reducing the cost of job assignment if we group certain tasks together?\n\nExact Algorithms: Look into papers by 1. Martello and Toth, 2. Korf\n\n\nApproximation algorithms:\n\nKarmarkar-Karp '82 ~ Find a packing with just O(log^2(n)) bins more than optimum in poly time.\n  - Gilmore Gomory LP relaxation of the bin packing problem with a big matrix\n  - Sort the elements by weight, then group them and round to the biggest in each group\n  - this reduces the matrix size dramatically.\n  - ...\n\nBetter: Discrepency theory -- R '13. Find packing with O(loglogn) bins more than optimum in poly-time\n\n\n\n----------------------\n\nOLD algo stuff...\n\nThis approach probably won't work... Not sure how to generate undominated sets with jobs...\nsimply generating subsets of 30 jobs blows the stack...\n\nPseudo-code for Korf Algorithm:\n\nCompute BFD solution.\nCompute Lower-Bound with the wasted space method (*)\nIf BFD Sol == Lower Bound then Stop -> return solution\nElse set BFD sol as current best complete solution\n     and start branch&bound search for strictly better solutions\n     pruning all partial solutions >= current best complete solution\n\nBranch and bound steps:\nOrder elements in decreasing order\nFor e in ordered_elements:\n  Find bin containing e\n  generate all undominated completions of bin (**)\n  if 0 or 1 undominated completion:\n    complete bin this way\n  else if more than 1 undominated completion:\n    order completions descending by sum\n    consider largest first, leave rest as branches\n    when complete solution is found and is better than current, update current best\n      -compute lower bound on partial solution (***)\n      - if worse than current best, prune partial solution\n\n\n(*) generating undominating terms:\nGenerate subsets of feasible completion\nTest them for dominance\n"
{"patch":[[[[0,"NP-hard."],[-1,""],[0,""],[1," "],[0,"\n\nFor ou"]],144,144,16,17],[[[0," skills."],[1," "],[0,"\n\nWe als"]],252,252,16,17],[[[0," skills."],[1," "],[0,"\n\nLet ea"]],321,321,16,17],[[[0," into a bin."],[1," "],[0,"\n\nIf the job"]],388,388,24,25],[[[0,"ll jobs."],[1," "],[0,"\n\nHere w"]],674,674,16,17],[[[0,"le jobs."],[1," "],[0,"\n\n\nWe ca"]],765,765,16,17],[[[0,"ogether?"],[1," "],[0,"\n\nExact "]],1466,1466,16,17],[[[0,"ly time."],[1," "],[0,"\n  - Gil"]],1660,1660,16,17],[[[0,"g matrix"],[1," "],[0,"\n  - Sor"]],1739,1739,16,17],[[[0,"me\n\n"],[-1,"\n\n----------------------\n\nOLD algo stuff...\n\nThis approach probably won't work... Not sure how to generate undominated sets with jobs...\nsimply generating subsets of 30 jobs blows the stack...\n\nPseudo-code for Korf Algorithm:\n\nCompute BFD solution.\nCompute Lower-Bound with the wasted space method (*)\nIf BFD Sol == Lower Bound then Stop -> return solution\nElse set BFD sol as current best complete solution\n     and start branch&bound search for strictly better solutions\n     pruning all partial solutions >= current best complete solution\n\nBranch and bound steps:\nOrder elements in decreasing order\nFor e in ordered_elements:\n  Find bin containing e\n  generate all undominated completions of bin (**)\n  if 0 or 1 undominated completion:\n    complete bin this way\n  else if more than 1 undominated completion:\n    order completions descending by sum\n    consider largest first, leave rest as branches\n    when complete solution is found and is better than current, update current best\n      -compute lower bound on partial solution (***)\n      - if worse than current best, prune partial solution\n\n\n(*) generating undominating terms:\nGenerate subsets of feasible completion\nTest them for dominance\n"]],1992,1992,1204,4]],"time":1425297816642}