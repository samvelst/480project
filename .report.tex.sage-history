"\\documentclass[12pt]{article}\n\\usepackage{amsmath,amssymb,amsthm}\n\\usepackage{graphicx}\n\\usepackage[ruled,vlined,linesnumbered]{algorithm2e}\n\n\\title{Optimizing Volunteer Shifts for Dance Weekends}\n\\author{John Jeng, Samvel Stepanyan}\n\\date{January 22nd, 2015}\n\\pagestyle{myheadings}\n\\markright{}\n\n% Custom commands\n\\newcommand{\\sumleft}{\\sum\\limits_{i=1}^n i^3}\n\\newcommand{\\sumright}{\\left(\\sum\\limits_{i=1}^n i \\right)^2}\n\\newcommand{\\Z}{\\mathbb{Z}}\n\\newcommand{\\C}{\\mathbb{C}}\n\\newcommand{\\pem}{$ (\\pi, E) $~}\n\n\\newtheorem{PF}{Proof}\n\\theoremstyle{definition}\n\\newtheorem{Def}{Definition}\n\\newtheorem{Thm}{Theorem}\n\\newtheorem{lemma}{Lemma}\n\n\\begin{document}\n%Begin Formalities========\n%=========================\n\\maketitle\n\\begin{abstract}\n\tYay \n\\end{abstract}\n\\newpage\n\\tableofcontents\n\\newpage\n%End Formalities=========\n%========================\n\n\\section{Introduction}\n\nSavoy Swing Club (SSC) is local non-profit organization that currently seeks to teach swing dancing to middle and high school kids in the greater Seattle area.\nThey are also heavily involved with 2 “dance weekends”: Seattle Lindy Exchange (SLX) and Killerdiller Weekend (KDW).\n\nThe format of dance weekends includes live bands, classe, performances, and competitions. All of these activities requires volunteers to make the weekend go smoothly.\nEach volunteer has a set of capabilities (sound, driving, door management, etc) and preferences for which hours (and possibly how many) they are volunteering.\nVolunteers are compensated based on the number of hours they work and the type of work.\nFor example, 8 hours of volunteering might mean “full pass” (access to all classes and evening dances) while fewer hours of volunteering might just mean a “dance pass” (only access to evening dances) or a “partial full pass” (eg. classes and evening dances on Saturday only).\nA technician however, might receive a full weekend pass and additional cash compensation for just 6 hours of work.\n\nGiven hourly requirements for various jobs and a set of volunteers, SSC would like to minimize the total compensation payout while adhering as much as possible to the volunteers’ preferences. As a side note, SSC would like to pay out in passes as much as possible over cash since the realized expense is much lower than raw cash expenses.\n\n\\section{Computer Science Reference}\n\n\n\\subsection{Introductory Notions}\n\n\n\\subsection{Basic Definitions}\n\n\\begin{Def}\n\tBig O notation:\n\n\tLet $f$ and $g$ be functions defined on some subset of the real numbers.\n\tThen we say that $f(x) = O(g(x))$ iff there exists a positive real number C and a real number $x_0$ such that\n\t\\[|f(x)| \\leq C|g(x)|\\text{ for all } x \\geq x_0\\]\n\\end{Def}\n\n\\begin{Def}\n\tA \\textit{loop invariant} is a condition that is necessarily true at the very beginning and very end of each iteration in some loop.\n\\end{Def}\n\n\\subsection{Priority Queues}\nA priority queue is a part of a class of objects in computer science called abstract data types (ADT). \nReal implementations vary but ADTs are used to analyze space requirements and running time.\n\nIn general, a priority queue can be thought of as an emergency room.\nHigher priority data (objects, patients) gets dequeued (processed, treated) before those of a lower priority.\nTypically this means there is a least value that is set as the highest priority.\n\nThe most basic priority queue just has the following methods (equivically understood as functions, jobs, utilities, capabilities, or features):\n\\begin{enumerate}\n\t\\item Add(Item i): This tells the priority queue to \"enqueue\" Item i which is to instruct it to appropriately place Item i into the wait list based on its priority.\n\t\\item Extract\\_min(): This tells the priority queue to return the \n\\end{enumerate}\nThis allows the program to store items based on their priorty and retrieve the highest priority one.\n\nRunning time for each operation varies on the implementation, but we will assume a fibonacci heap in our case.\nThus Add and Update\\_priority will run in $O(1)$ time and Extract\\_min will run in $O(\\log n)$ time where $n$ is the number of items in the priority queue.\n\n\\subsection{Trees}\nFor these next two subsections, our starting novice may do well to read the introductory section on Graph Theory.\n\n\n\\subsection{Dijkstra}\nIn this section we introduce Dijkstra's a algorithm for shortest path on general graphs with non-negative edge weights as we will emulate it in our main result.\n\nThe idea behind Disjkstra's algorithm is to mark all nodes that aren't the source node to initiailly to have a distance (denoted $d[v]$) equal to infinity. \nThen, as we traverse the graph from the source node, we update the shortest path to each v until we have traversed the entire graph.\n\nWhen implemented with a fibbonacci heap, Disjkstra's algorithm runs in $O (m + n\\log n)$ time where m is the number of edges and n is the number of vertices.\nWe will not prove its correctness or running time here as it can be found in any introductory text on algorithms. \n\n\\begin{algorithm}[H]\n\\DontPrintSemicolon\ndist[$source$] := 0\\;\n\\ForEach{vertex $v$ in Graph}{\n\t\\If{$v \\neq source$}{\n\t\tdist[$v$] := infinity\\;\n\t\tprevious[$v$] := undefined\\;\n\t}\n\tPQ.add($v$, dist[$v$])\\;\n}\n\\While{PQ is not empty}{\nu := PQ.extract\\_min()\\;\n\\ForEach{neighbor v of u}{\n\talt = dist[u] + length(u,v)\\;\n\t\\If{$\\text{alt} < \\text{dist}[v]$}{\n\t\tdist[v] := alt\\;\n\t\tprevious[v] := u\\;\n\t\tPQ.decrease\\_priority(v,alt)\\;\n\t}\n}\n}\n\\caption{Dijkstra's algorithm}\n\\end{algorithm}\n\n\n\\begin{thebibliography}{9}\n\\bibitem{Fed87}\n\tGreg N Federickson.\n\tFast algorithms for shortest paths in planar graphs, with applications.\n\tSIAM Journal on Computing, 16(6):1004-1022,\n\t1987\n\n\\bibitem{Klein13}\n\tMonika R. Henzinger, Philip Klein, Satish Rao, Sairam Subramanian.\n\tFaster Shortest-Path Algorithms for Planar Graphs\n\tJournal of Computer and System Sciences Article NO. SS971493\n\t1997\n\n\\end{thebibliography}\n\n\\end{document}\n"
{"patch":[[[[0,"ction}\n\n"],[1,"\\t"],[0,"Savoy Sw"]],869,869,16,18]],"time":1421970189599}
{"patch":[[[[0,"ion}\n\n\\t"],[1," "],[0,"Savoy Sw"]],871,871,16,17]],"time":1421970188885}
{"patch":[[[[0,"ion}\n\n\\t"],[-1," "],[0,"Savoy Sw"]],871,871,17,16]],"time":1421970172539}
{"patch":[[[[0,"ion}\n\n\\t"],[1,"ab"],[0,"Savoy Sw"]],871,871,16,18]],"time":1421970171685}
{"patch":[[[[0,"n}\n\n\\tab"],[1," "],[0,"Savoy Sw"]],873,873,16,17]],"time":1421970170757}
{"patch":[[[[0,"n}\n\n\\tab"],[-1," "],[1,"e"],[0,"Savoy Sw"]],873,873,17,17]],"time":1421970169263}
{"patch":[[[[0,"on}\n\n\\ta"],[-1,"be"],[0,"Savoy Sw"]],872,872,18,16]],"time":1421970168548}
{"patch":[[[[0,"ion}\n\n\\t"],[-1,"a"],[0,"Savoy Sw"]],871,871,17,16]],"time":1421970167796}
{"patch":[[[[0,"tion}\n\n\\"],[-1,"t"],[0,"Savoy Sw"]],870,870,17,16]],"time":1421970166989}
{"patch":[[[[0,"ction}\n\n"],[-1,"\\"],[0,"Savoy Sw"]],869,869,17,16]],"time":1421970166239}
{"patch":[[[[0,"(KDW).\n\n"],[1,"\n"],[0,"The form"]],1147,1147,16,17]],"time":1421970157879}
{"patch":[[[[0," work.\n\n"],[1,"\n"],[0,"Given ho"]],1954,1954,16,17]],"time":1421970157089}
{"patch":[[[[0," work.\n\n"],[-1,"\n"],[0,"Given ho"]],1954,1954,17,16]],"time":1421970148387}
{"patch":[[[[0," work.\n\n"],[1,"\n"],[0,"Given ho"]],1954,1954,16,17]],"time":1421970139026}
{"patch":[[[[0,"oothly.\n"],[1,"\n"],[0,"Each vol"]],1315,1315,16,17]],"time":1421970127312}
{"patch":[[[[0,"le area."],[-1,"\n"],[0,"They are"]],1028,1028,17,16]],"time":1421970118410}
{"patch":[[[[0,"le area."],[1," "],[0,"They are"]],1028,1028,16,17]],"time":1421970117640}
{"patch":[[[[0,"moothly."],[1,"\\"],[0,"\n\nEach v"]],1314,1314,16,17]],"time":1421970111773}
{"patch":[[[[0,"othly.\\\n"],[-1,"\n"],[0,"Each vol"]],1316,1316,17,16]],"time":1421970111061}
{"patch":[[[[0,"moothly."],[-1,"\\"],[0,"\nEach vo"]],1314,1314,17,16]],"time":1421970110232}
{"patch":[[[[0,"y only)."],[1," "],[0,"\nA techn"]],1837,1837,16,17]],"time":1421970099405}
{"patch":[[[[0," only). "],[-1,"\n"],[0,"A techni"]],1838,1838,17,16]],"time":1421970098655}
{"patch":[[[[0,"y one.\n\n"],[1,"\n"],[0,"Running "]],3838,3838,16,17]],"time":1421970090025}
{"patch":[[[[0,"y one.\n\n"],[1,"However, our priority queues will additionally require the following method:\n\\begin{enumerate}\n\t\\item Update\\_priority(Item i, Priority p): This tells the priority queue to update the priority of i to p.\n\\end{enumerate}\n"],[0,"\nRunning"]],3838,3838,16,236]],"time":1421970089099}
{"patch":[[[[0,"of work."],[-1,"\n"],[0,"For exam"]],1561,1561,17,16]],"time":1421970079353}
{"patch":[[[[0,"of work."],[1," "],[0,"For exam"]],1561,1561,16,17]],"time":1421970078640}
{"patch":[[[[0,"teering."],[-1,"\n"],[0,"Voluntee"]],1473,1473,17,16]],"time":1421970076895}
{"patch":[[[[0,"teering."],[1," "],[0,"Voluntee"]],1473,1473,16,17]],"time":1421970076147}
{"patch":[[[[0,"moothly."],[-1,"\n"],[0,"Each vol"]],1314,1314,17,16]],"time":1421970070820}
{"patch":[[[[0,"moothly."],[1," "],[0,"Each vol"]],1314,1314,16,17]],"time":1421970070066}
{"patch":[[[[0,"f work.\n"],[1,"\\\n"],[0,"\n\nGiven "]],1953,1953,16,18]],"time":1421970066034}
{"patch":[[[[0," work.\n\\"],[1,"newlin"],[0,"\n\n\nGiven"]],1954,1954,16,22]],"time":1421970065324}
{"patch":[[[[0,"\n\\newlin"],[1,"e"],[0,"\n\n\nGiven"]],1960,1960,16,17]],"time":1421970064530}
{"patch":[[[[0,"(KDW).\n\n"],[-1,"\n"],[0,"The form"]],1147,1147,17,16]],"time":1421970059757}
{"patch":[[[[0," (KDW).\n"],[1,"\\new"],[0,"\nThe for"]],1146,1146,16,20]],"time":1421970059032}
{"patch":[[[[0,"W).\n\\new"],[1,"line"],[0,"\nThe for"]],1150,1150,16,20]],"time":1421970058245}
{"patch":[[[[0,"newline\n"],[1,"\n"],[0,"The form"]],1155,1155,16,17]],"time":1421970057496}
{"patch":[[[[0,"rithm}\n\n"],[1,"\\section{Basic Graph Theory}\nWe begin by defining G = (V, E) to be a graph G with set of vertices V and edges E. \nEdges may be directed, undirected, or bidirected.\nIn all generality though, there only arcs which specify a beginning and end vertex.\nWe will therefore make the following distinctions.\nWhen direction does not matter, we will refer to the connection between two vertices as simply an edge.\nWhen direction matters we will specifically say arc instead of edge in which case the reader does well to pay attention to its direction.\n\nOur graphs here will be edge centric instead of vertex centric.\nThat is, given a set E of edges, we shall define V to be a partition of the \\textit{dart set}, $E \\times \\{1,-1\\}$ (where $\\times$ is the cartesian product). \nThe dart set represents the tails and heads of arcs (or edges in the case of an undirected graph).\n\nFor example, if $E$ is the set of edges, and $E = \\{a, b, c, d\\}$ then the dart set is \n\\\\$D = \\{(a, 1), (a, -1), (b, -1), (b, -1), (c, 1), (c, -1), (d, 1), (d, -1)\\}$, which we could partition to form an arbitrary vertex $v = \\{(a, 1), (b, -1), (b, 1)\\}$.\nFor the graph $G = (V, E)$, $V$ would be a set of such vertices and since it is a partition of $D$, it follows that no dart $d \\in D$ can appear more than once.\nIn this example vertex $v$ has the arc $a$ leaving it and the arc $b$ as a self-loop.\n\nFor a graph G = (V, E), we denote V(G) and E(G) to be the vertices and edges of G respectively.\n\n\\begin{Def} $\\text{rev} (e, \\sigma) = (e, -\\sigma)$. Which is called the reverse of a dart d.\n\\end{Def}\n\n\\begin{Def} A \\textit{walk} of a graph G is seqence of vertices and edges $v_1, e_1, v_2, e_2, \\ldots, v_n$ such that $e_i$ is an arc from $v_i$ to $v_{i+1}$.\n\\end{Def}\n\n\\begin{Def} A \\textit{cycle} of a graph G is a walk of G where the beginning vertex and end vertex are the same.\n\\end{Def}\nA cycle is \\textit{simple} if the only vertex to appear twice is the first one.\n\n\\begin{Def} A graph is \\textit{simple} if every vertex has no self edges (ie.\\ darts $ (e, \\pm1)$ are not part of the same vertex) and any two vertices have at most 1 edge between them.\n\\end{Def}\n\n\\begin{Def} A graph is \\textit{connected} if for every vertex $u \\in V$ there exists a walk $W$ from $v$ to every other vertex $u$ in $V$.\n\\end{Def}\n\n\\begin{Def} A \\textit{connected component} of a graph G is a subset $V'$ of $V$ for which, for every vertex $u' \\in V'$, there does not exist a walk to any vertex $u \\notin V', u \\in V$.\n\\end{Def}\n\n\\begin{Def} A graph is \\textit{complete} if there is an edge between every vertex. We denote these graphs $k_i$ where $i$ is the number of nodes.\n\\end{Def}\n\n\\begin{Def} Informally, an \\textit{embedding} of a graph G is a drawing of G onto some surface S in which the edges only touch at the end points.\n\\end{Def}\nIt does us no better in the case of this paper to formally define an embedding.\nWe do note however that any graph can embedded in 3-dimensional Euclidean space.\n\n%===========================================================================================\n%===========================================================================================\n\\section{Planarity and Properties}\n%===========================================================================================\n%===========================================================================================\n\nWhy do we care about planarity?\nPlanarity gives us some nice properties.\nThe most importantly, as we shall see, there is a sense in which local changes in the graph cannot have `too much' global effect.\nInformally we define a planar graph to be any graph that can be embedded onto the plane.\n\n\\includegraphics[scale=0.07]{plane.png}\n\n\\noindent\nTo define it formally, we first build some machinery.\n\n\\begin{Def}\n\tA \\textit{contraction} of edge $e$ with end vertices $u$ and $v$ in a graph $G = (V, E)$ is to replace $u$ and $v$ with an node $n = (v \\cup u)\\ {(e, \\pm1)}$.\n\\end{Def}\n\n\\begin{Def}\n\tAn \\textit{edge deletion} is just the removal of an edge $e$ from the set of edges $E$.\n\t\\newline\n\tA \\textit{vertex deletion} of a vertex $v$ is the removal of the set of edges whose end points include $v$.\n\\end{Def}\n\nIt turns out that we can define a graph $G$ to be planar if after some number of contractions and deletions to $G'$, $G'$ is not $k_5$ or $k_{3,3}$\n\\newline\n\\includegraphics[scale=.6]{minors.png}\n$k_5$ and $k_{3,3}$ respectively.\n\n\\begin{Thm}\n\tFor any simply connected planar graph, there is a way to partition it into 3 subgraphs $A$, $S$, and $B$ such that the ``size'' of $A$ and $B$ do not exceed $m\\cdot g$ where $g$ is the ``size'' of the graph and $m \\in (1/2, 1)$.\n\\end{Thm}\n\nThis theorem basically says that we can cut up the graph into subgraphs and guarantee the pieces will be a certain percent of the vertices of the original graph.\nNotice that in the, albeit simple, cases of $k_n$, $n > 4$ this is obviously not possible.\n\n\n\\subsection{Recursive Divisions of Planar Graphs}\nIn this section we define several notions of examining a planar graph that will be used heavily in our algorithm.\n\nThough we will not show it, a (true) result we will need is the following:\n\\begin{Thm} For any integer $r$, there is a linear time algorithm that will produce a decomposition tree that is a recursive r-division of a graph G.\n\\end{Thm}\n\nTo understand what this theorem means, we define the following terms.\n\n\\begin{Def} A \\textit{region} $R$ of $G$ is an edge-induced subgraph of $G$.\nThat is, $R$ is a set of connected edges of $G$ with any vertices that are their endpoints.\n\\end{Def}\n\n\\begin{Def} A \\textit{division} of G is a collection of regions such that each edge is in at least one region. That is, every edge in G is accounted for by the collection of regions.\n\\end{Def}\n\n\\begin{Def} A vertex $v$ is a \\textit{boundary} vertex of a division if it is in more than one region.\n\\end{Def}\n\n\\begin{Def} An \\textit{r-division} of G is a decomposition of G into $O (n/r)$ regions that have following properties:\n\\begin{itemize} \\itemsep1pt\n\\item Contain $\\leq$ r vertices\n\\item Have $O (\\sqrt{r}) $ boundary vertices.\n\\end{itemize}\n\\end{Def}\nFrederickson [] showed that we can do this in $O (n\\log r + n r^{-1/2} \\log n)$ using the planar separator theorem.\n\\newline\n\n\\noindent\nSuppose $R_1$ and $R_2$ are two different regions of G.\n\\begin{Def} A \\textit{recursive r-division} of G results in a rooted tree of the following structure:\n\\begin{itemize} \\itemsep1pt\n\t\\item The root is the entirety of G.\n\t\\item Each level of the tree makes up an r-division of G.\n\t\\item $R_1$ is the \\textit{anscestor} of $R_2$ iff $R_1$ contains $R_2$ as a subgraph\n\t\\item $R_1$ is the \\textit{parent} of $R_2$ iff it is the immediate ancestor.\n\tIn this case, $R_2$ is known as the \\textit{child} of $R_1$.\n\t\\item The level of a region R in this tree is the height of R in the tree.\n\t\tThus all single edges are of height 0.\n\\end{itemize}\n\\end{Def}\n\n\\textit{Note}: Recursive r-divisions are, in general, not unique. \n\n\\section{HKRS}\nIn this section we present Henzinger, Klein, Rao, and Subramanian's linear time algorithm for finding shortest path in a planar graph with non-negative edge weights.\n\nThis is a speed up over Dijkstra's algorithm implemented with a Fibbonacci heap for general non-negative edge weighted graphs which has a running time of $O (n + m\\log m)$ where $n$ is the number of vertices and $m$ is the number of edges. \n\nThe idea of this algorithm is to implement Dijkstra's algorithm on a recursive r-division of G. The algorithm ``jumps around'' to avoid the $O (n \\sqrt{\\log{n}})$ running time of Fredrickson's prior work [1].\n\nPresented below are the two methods that are called by the main algorithm.\n\n\\begin{algorithm}[H]\n\t\\If{R contains a single edge uv}{\n\t\t\\If{d[v] $>$ d[u] + length(uv)}{\n\t\t\td[v] := d[u] + length(uv)\\;\n\t\t\t\\ForEach{outgoing edge vw from v}{\n\t\t\t\tGlobalUpdate(R(vw), uw, d[v])\\;\n\t\t\t}\n\t\t}\n\t\tupdateKey(Q(R), uv, $\\infty$)\\;\n\t}\n\t\\Else{\n\t\t\\For{ $\\alpha_{l(R)}$ times or until minKey(Q(R)) = $\\infty$}{\n\t\t\t$R'$ := minItem(Q(R))\\;\n\t\t\tProcess(R')\\;\n\t\t\tupdateKey(Q(R), R', minKey(Q(R')))\\;\n\t\t}\n\t}\n\t\\caption{Process(R)}\n\\end{algorithm}\n\t\n\\begin{algorithm}\n\toldmin := minKey(Q(R))\\;\n\tupdateKey(Q(R), x, k)\\;\n\tnewmin := minKey(Q(R))\\;\n\t\\If{newmin $<$ oldmin}{\n\t\tGlobalUpdate(parent(R), R, k)\\;\t\n\t}\n\t\\caption{GlobalUpdate(R, x, k)}\n\\end{algorithm}\n\n\\subsection{Algorithm Walkthrough}\nIn the following sections we will refer to points in these methods by the following scheme:\n\\[P:x, GU:y,\\text{\\qquad where } x, y \\text{ are line numbers in each method.}\\]\neg. P:4 is line 4 in Process and begins with ``foreach''. GU:5 is the last line in GlobalUpdate.\n\nWe begin by noting that the graph G is equipped with a recursive r-division and priority queue.\nThat is, every piece has its children stored in a priority queue.\nEvery node $v$ has a label $d[v]$ which is separate from the key k for which it might have for any one of the priority queues it's in.\n\nOur GlobalUpdate method takes a region R, piece x, and value k.\nFirst we update key of x in the region R's priority queue to value k.\nNote that due to the conditions Process and in our main algorithm, updateKey can only lower the value of x.\nNext, we check if this has reduced the minimum value for this priority queue.\nIf it has, we recursively inform the ancestors about this update until it is not a new minimum for one of the regions.\nThis guarantees that every parent knows about each child's minimum value.\nNote that in the case of a single edge $uv$, its parent may not be unique.\nIn this case, all parents of $uv$ are updated as long as it is a new miniumum.\n\nOur Process method only takes a region R.\nWe will describe the two parts of Process separately.\nWe will refer to the first If section as $P_1$ and the Else section as $P_2$.\n\n$P_1$ is simply the case that the region R given is really just one edge.\nIn this case we want to look at the length of that edge and compare it to the current marked distance for that vertex.\nIf it is a shorter path, we want to call GlobalUpdate appropriately so that the algorithm ``knows'' this shorter path.\n\nIn the case of $P_2$, R is a complete piece of our graph G.\nWe now want to call Process on the minimum child of R $\\alpha_l$ times where $l$ is the level of the region R and $\\alpha$ is function of $l$.\nWe also stop calling Process when the minKey() of the region's priority queue is infinity which implies that all of the keys are infinity thus every child is relaxed.\nEvery time we call Process for a child of R, we then want to update the value of that child in R's priority queue of children to the minimum value in that child's priority queue.\nIn this manner we see that the value for each piece is the current known minimum path through that piece.\n\nNote that for any region $R$, we may call Process($R$) more than once but each invocation will be distinct.\n\n\\subsubsection{Running the algorithm}\nWe begin the algorthm by initializing the source node distance $d[v]$ to 0 and all other distances to $\\infty$.\nNext we call GlobalUpdate(R($sw$), $sw$, 0) for each outgoing edge w from the source s.\nIn this manner every region in the recursive division tree that contains $sw$ \"knows\" the distance sw.\n\nFor this algorithm, we denote an \\textit{active} edge to be one where the key of $Q(R(uv))$ is finite. \nAn edge is \\textit{inactive} otherwise.\nAn edge is \\textit{relaxed} if \\dots\n\nTo prove that every edge is inactive at the end of the algorithm, we first show that if an edge is inactive then it is relaxed and at the end of the algorithm all edges are inactive.\nHowever, we will first have some comments on the algorthm's running time.\n\n\\subsection{Running Time}\n\\begin{Thm}\n\tHKRS runs in linear time for any planar graph with non-negative edge weights.\n\\end{Thm}\nThe complete proof for the running time for this algorithm is beyond the scope of this paper, however, we shall present some of the main ideas from the proof.\nTo compute running time we would like to analyze the cost of running Process and GlobalUpdate.\n\n\\subsubsection{Analysis of Process}\nIn our analysis of the Process method, we would like to bound the number of calls to Process.\nIt turns out, there are two ``types'' of calls to Process.\n\nIn the latter portion of an invocation $A$ of Process, it may end either due to the loop running $\\log n$ times or because there are no longer any active edges (ie. they all have a distance of infinity).\nWe call such an invocation to be \\textit{truncated} if it was caused by a lack of active edges.\nFurther note that every 0-level invocation is truncated and when the highest level invocation is truncated, the algorithm terminates.\n\nConsider an invocation $A$ of a call to Process.\nWe define the following terms for $A$.\nThe \\textit{region} of $A$ is the region $R$ to which Process is applied.\nThe \\textit{level} of $A$ is the level of its region $R$.\nA \\textit{child} of $A$ is an invocation $B$ such that $B$ was the resulting call to Process at near the end of $A$. \nIn such a case, $A$ is known as the \\textit{parent} of $B$.\n\\textit{Descendants} and \\textit{ancestors} are thus defined as expected.\n\nChildren of an invocation $A$ are \\textit{ranked} according to when they occur in time.\n\nNow we define an \\textit{entry node} of a region.\nFor a 0-level region R($uv$), $u$ is an entry node of the region. \nFor the top level region G, the only entry node is the source s.\nFor  region $R$ in between, an entry vertex $v$ of $R$ is any boundary node of the region with an arc to another node inside the region.\nRecall that regions may overlap each other at boundary nodes and thus these are the only places in which a shorter path in one region may affect the shortest path in another.\n\nIf $R_{\\text{adj}}$ is the region for which an updated in $R$ causes a reduction in the minKey() of $R_{\\text{adj}}$ we call this a \\textit{foreign intrusion of region $R_{\\text{adj}}$ via entry vertex $v$}.\nObviously if there are two intrusions on the same region  $R_{\\text{adj}}$ via the same node v, each at different times, then minKey() of $R_{\\text{adj}}$ must be the least after the second time since an intrusion only counts when it lowers the $d[v]$.\n\n\\begin{Def}\n\tA \\textit{charger} C of a pair ($R$, $v$) where $R$ is a region and v is a $v$ is an entry node of $R$, is an invocation of Process that has been truncated.\n\\end{Def}\n\n\\begin{Thm}\n\tFor any pair ($R$, $v$), there exists an invocation C of Process such that its region is $R$ and all other charges of $R$ are descendents of $C$.\n\\end{Thm}\n\nThe idea of this \"charging scheme\" is that for a certain amount of work in any region $R$, there is actually a specific node that we can ``blame''.\nThus we can account for each method call in a certain sense by each node.\nIt relies on the idea that after some time, the shortest paths in a region can only change because the edge of an entry vertex was changed by a call to Process on a different region. \nWe are able to bound the number of these calls because the r-divisions guarantee a certain number of boundary nodes and also the size of the region to be appropriately small.\nWe gain further time gains from multiple level priority queues since the queues at lower levels take significantly less time than if all edges were stored in the same queue.\nFor example, the retrieving the miniumum for a priority queue of one element is always constant time.\n\n\\begin{lemma}\n\tThe total time for the algorithm, not including time spent in GlobalUpdate is\n\t\\[O\\left(\\sum_{j\\geq 0} s_j\\alpha_j\\log r_j\\right)\\]\n\\end{lemma}\n\nThough we will not present it, it turns out this is just dependent on how we do our recursive r-division of the graph $G$.\n\n\\subsubsection{Analysis of GlobalUpdate}\nNow we analyze the time spent in GlobalUpdate. \nConsider a level-0 invocation $A_0$ of Process and let $R(uv)$ be its atomic region.\nSince we assumed It makes at most two calls GlobalUpdate($R(vw)$, $vw$, $d[v]$).\nEach call leads to a series of recursive calls to GlobalUpdate involving regions $R_i$ containing $vw$ where $R_{i+1}$ is the parent region of $R_i$.\nThe call involving region $R_i$ requires $O(\\log r_i)$ time (not including all recursive calls), so the total time for the series of calls is\n\\[\\sum_{i=1}^p O(\\log r_i).\\]\n\nThe key point in analyzing the run time of GlobalUpdate again depends upon analyzing charging calls and normal calls.\nBy our recursive r-division, if we have a GlobalUpdate go all the way to the top level, we have reduced the number of other calls that can go to the top level.\nIn that sense we can bound the amount of recursive calls to GlobalUpdate.\nWe bound the other calls based on the number of boundary nodes that regions are allowed to have.\n\n\\subsection{Correctness}\nTo prove correctness, it turns out we just need to satisfy 3 properties: [citation needed]\n\\begin{enumerate}\n\t\\item $d[s] = 0$\n\t\\item $\\forall v: d[v] \\geq d_G(s,v)$\n\t\\item $\\forall v, w\\in E: d[w] \\leq d[v] + length(v,w)$\n\\end{enumerate}\n\nThe first two are easy; we initialize $d[s] = 0$ and never change it while the label $d[v]$ is never updated unless it satisfies condition 2.\n\n\\begin{lemma}\n\tFor each node v, throughout the algorithm, the label d[v] is an upperbound on the distance from s to v.\n\\end{lemma}\n\\begin{PF}\n\tWe proceed by induction on the number of steps of the algorithm that have been executed.\n\tEvery every label $d[v]$ is initially $0$ except that of s.\n\tWe only change labels in the second line of the process method. \n\tSince that line always gives an upperbound, it follows that every new value is also an upperbound. [2]\n\\end{PF}\n\n\\begin{lemma}\n\tIf and edge uv is inactive then it is relaxed (except when we update the distance).\n\\end{lemma}\n\\begin{PF}\n\tThe lemma holds before the first call to Process since at that point every node but $s$ has a label of infinity and every outgoing edge of $s$ is active. The algorithm only deactivates an edge $uv$ just after the edge is relaxed. \n\n\tAn edge $vw$ can become unrelaxed when the labels of its end points change.\n\tNote that labels never go up.\n\tThe label of $v$ might go down in the second line of Process, but the algorithm then immediately calls GlobalUpdate(R($vw$), $vw$, $d[v]$) for each outgoing edge of $vw$ from $v$.\n\tThen in the first step of GlobalUpdate, the key of $vw$ is updated to a finite value so $vw$ \"stays\" active. [2]\n\\end{PF}\n\n\\begin{lemma}\n\tThe key of an active edge uw is $d[v]$ (except when we update the distance).\n\\end{lemma}\n\\begin{PF}\n\tInitially all labels and keys are infinity.\n\tThus none of them are active then.\n\tEverytime a vertex $v$ has its label $d(v)$ assigned a new value $k$, GlobalUpdate(R($vw$), $vw$, k) is called on each outgoing edge $vw$.\n\tThen GlobalUpdate correctly changes the key of $vw$ to k. [2]\n\\end{PF}\n\n\\begin{lemma}\n\tFor any region R that is not an ancestor of the current region, the key associated with R in $Q(\\text{parent}(R))$ is the min key of $Q(R)$.\n\\end{lemma}\n\\begin{PF}\n\tAt the very beginning of the algorithm, all kets are infinity.\n\tThus in this case the lemma holds trivially.\n\tEvery time the minimum key of some queue $Q(R)$ is changed in the first step of GlobalUpdate, a recursive call to GlobalUpdate in the method ensures that the key associated with $R$ in the queue of the parent of R is also updated\n\n\tWe must also consider the moment when a new region becomes the current region. This happens upon invocation of Process and upon returnning from Process. When Process($R$) is newly invoked, the new current region $R$ is a child of the old current region, so this Lemma applies to even fewer regions than before; hence, we know it continues to hold. \n\tWhen Process($R$) returns, the parent of the previous current region R becomes current.\n\tHence at the point Lemma 3.4 applies to $R$.\n\tNote, however, that immediately after the call to Process($R$), the calling invocation, which is Process(parent($R$)), updates the key of $R$ in the priority queue of $R$'s parent to the value of minKey() of the priority queue of $R$.[2]\n\\end{PF}\n\nNow we prove the correctness of the invariant for the algorithm.\nThis invariant implies that, when the algorithm terminates, the labels are correct.\n\n\\begin{Thm}\n\tFor any region R that is not an ancestor of the current region,\n\\[\\text{minKey(Q(R))} = \\text{min}\\{d[v]: \\text{ uv is a pending edge contained in R}\\}\\]\n\\end{Thm}\n\n\\begin{PF}\n\tBy induction on the level of R using lemma 4 from above.\n\\end{PF}\n\nThus we have that the algorithm correctly computes the shortest path to each node $v$ from a source $s$.\n"],[0,"\n\\begin{"]],5706,5706,16,20551]],"time":1421969991446}
{"patch":[[[[0,"uction}\n"],[-1,"\n"],[0,"Savoy Sw"]],868,868,17,16]],"time":1421968606919}
{"patch":[[[[0,"ewline\n\n"],[1,"\\"],[0,"\nGiven h"]],1970,1970,16,17]],"time":1421968568964}
{"patch":[[[[0,"ewline\n\n"],[1,"\\"],[0,"\\\nGiven "]],1970,1970,16,17]],"time":1421968568210}
{"patch":[[[[0,"k.\n\\newl"],[-1,"ine\n"],[0,"\n\\\\\nGive"]],1965,1965,20,16]],"time":1421968566625}
{"patch":[[[[0," work.\n\\"],[-1,"newl"],[0,"\n\\\\\nGive"]],1961,1961,20,16]],"time":1421968565913}
{"patch":[[[[0,"f work.\n"],[-1,"\\"],[0,"\n\\\\\nGive"]],1960,1960,17,16]],"time":1421968565121}
{"patch":[[[[0,"f work.\n"],[-1,"\n"],[0,"\\\\\nGiven"]],1960,1960,17,16]],"time":1421968564329}
{"patch":[[[[0,").\n\\newl"],[-1,"ine"],[0,"\n\nThe fo"]],1150,1150,19,16]],"time":1421968562785}
{"patch":[[[[0,"KDW).\n\\n"],[-1,"ewl"],[0,"\n\nThe fo"]],1147,1147,19,16]],"time":1421968562069}
{"patch":[[[[0,"(KDW).\n\\"],[-1,"n"],[0,"\n\nThe fo"]],1146,1146,17,16]],"time":1421968561279}
{"patch":[[[[0," (KDW).\n"],[-1,"\\"],[0,"\n\nThe fo"]],1145,1145,17,16]],"time":1421968560143}
{"patch":[[[[0,"(KDW).\n\n"],[-1,"\n"],[0,"The form"]],1146,1146,17,16]],"time":1421968544275}
{"patch":[[[[0," (KDW).\n"],[1,"\\newline"],[0,"\nThe for"]],1145,1145,16,24]],"time":1421968543486}
{"patch":[[[[0,".\n\\newli"],[-1,"ne"],[0,"\nThe for"]],1151,1151,18,16]],"time":1421968527649}
{"patch":[[[[0,"(KDW).\n\\"],[-1,"newli"],[0,"\nThe for"]],1146,1146,21,16]],"time":1421968526856}
{"patch":[[[[0," (KDW).\n"],[-1,"\\"],[1,"'"],[0,"\nThe for"]],1145,1145,17,17]],"time":1421968525388}
{"patch":[[[[0," (KDW).\n"],[-1,"'"],[0,"\nThe for"]],1145,1145,17,16]],"time":1421968524598}
{"patch":[[[[0," (KDW).\n"],[1,"\\\\\\"],[0,"\nThe for"]],1145,1145,16,19]],"time":1421968523880}
{"patch":[[[[0,"DW).\n\\\\\\"],[1,"\\"],[0,"\nThe for"]],1148,1148,16,17]],"time":1421968523131}
{"patch":[[[[0,"KDW).\n\\\\"],[-1,"\\\\"],[0,"\nThe for"]],1147,1147,18,16]],"time":1421968513980}
{"patch":[[[[0,"KDW).\n\\\\"],[1," \\\\"],[0,"\nThe for"]],1147,1147,16,19]],"time":1421968513226}
{"patch":[[[[0,"DW).\n\\\\ "],[-1,"\\\\"],[0,"\nThe for"]],1148,1148,18,16]],"time":1421968512512}
{"patch":[[[[0,"KDW).\n\\\\"],[-1," "],[0,"\nThe for"]],1147,1147,17,16]],"time":1421968511730}
{"patch":[[[[0," (KDW).\n"],[-1,"\\\\"],[1,"/"],[0,"\nThe for"]],1145,1145,18,17]],"time":1421968510464}
{"patch":[[[[0,"(KDW).\n/"],[1,"/"],[0,"\nThe for"]],1146,1146,16,17]],"time":1421968509749}
{"patch":[[[[0,"(KDW).\n/"],[-1,"/"],[0,"\nThe for"]],1146,1146,17,16]],"time":1421968499848}
{"patch":[[[[0," (KDW).\n"],[-1,"/"],[1,"\\"],[0,"\nThe for"]],1145,1145,17,17]],"time":1421968498990}
{"patch":[[[[0,"(KDW).\n\\"],[1,"\\"],[0,"\nThe for"]],1146,1146,16,17]],"time":1421968496556}
{"patch":[[[[0,"d (KDW)."],[1," "],[0,"\n\\\\\nThe "]],1144,1144,16,17]],"time":1421968490755}
{"patch":[[[[0,"of work."],[1," "],[0,"\n\\\\\nGive"]],1953,1953,16,17]],"time":1421968489155}
{"patch":[[[[0,"work. \n\\"],[-1,"\\"],[0,"\nGiven h"]],1956,1956,17,16]],"time":1421968485623}
{"patch":[[[[0," work. \n"],[-1,"\\"],[0,"\nGiven h"]],1955,1955,17,16]],"time":1421968484846}
{"patch":[[[[0,"(KDW). \n"],[-1,"\\\\"],[1,"/"],[0,"\nThe for"]],1146,1146,18,17]],"time":1421968481413}
{"patch":[[[[0,"KDW). \n/"],[1,"/"],[0,"\nThe for"]],1147,1147,16,17]],"time":1421968480625}
{"patch":[[[[0,"KDW). \n/"],[-1,"/"],[0,"\nThe for"]],1147,1147,17,16]],"time":1421968479232}
{"patch":[[[[0,"(KDW). \n"],[-1,"/"],[0,"\nThe for"]],1146,1146,17,16]],"time":1421968478451}
{"patch":[[[[0,"on}\n"],[-1,"Savoy Swing Club (SSC) is local non-profit organization that currently seeks to teach swing dancing to middle and high school kids in the greater Seattle area. They are also heavily involved with 2 “dance weekends”: Seattle Lindy Exchange (SLX) and Killerdiller Weekend (KDW). \n\nThe format of dance weekends includes live bands, classe, performances, and competitions. All of these activities requires volunteers to make the weekend go smoothly. Each volunteer has a set of capabilities (sound, driving, door management, etc) and preferences for which hours (and possibly how many) they are volunteering. Volunteers are compensated based on the number of hours they work and the type of work. For example, 8 hours of volunteering might mean “full pass” (access to all classes and evening dances) while fewer hours of volunteering might just mean a “dance pass” (only access to evening dances) or a “partial full pass” (eg. classes and evening dances on Saturday only). A technician however, might receive a full weekend pass and additional cash compensation for just 6 hours of work. \n\nGiven hourly requirements for various jobs and a set of volunteers, SSC would like to minimize the total compensation payout while adhering as much as possible to the volunteers’ preferences. As a side note, SSC would like to pay out in passes as much as possible over cash since the realized expense is much lower than raw cash expenses."],[0,"\n\n\\s"]],872,872,1432,8]],"time":1421968451866}
{"patch":[[[[0,"t}\n\tYay "],[1,"ab"],[0,"\n\\end{ab"]],741,741,16,18]],"time":1421968426248}
{"patch":[[[[0,"}\n\tY"],[-1,"ay ab"],[0,"\n\\en"]],742,742,13,8]],"time":1421968424725}
{"patch":[[[[0,"ract}\n\tY"],[1,"AY "],[0,"\n\\end{ab"]],738,738,16,19]],"time":1421968423969}
{"patch":[[[[0,"t}\n\tYAY "],[1,"ABSTRACT"],[0,"\n\\end{ab"]],741,741,16,24]],"time":1421968423257}
{"patch":[[[[0,"ABSTRACT"],[1," "],[0,"\n\\end{ab"]],749,749,16,17]],"time":1421968422465}
{"patch":[[[[0,"tle{"],[-1,"Optimizing Volunteer Shifts for Dance Weekend"],[1,"Shortest Path on Planar Graphs with Non-negative Edge Weight"],[0,"s}\n\\"]],145,145,53,68]],"time":1421968393879}
{"patch":[[[[0,"2nd, 201"],[-1,"5"],[0,"}\n\\pages"]],264,264,17,16]],"time":1421968356273}
{"patch":[[[[0,"2nd, 201"],[1,"4"],[0,"}\n\\pages"]],264,264,16,17]],"time":1421968355521}
{"patch":[[[[0,"ry 2"],[-1,"2nd"],[0,", 20"]],260,260,11,8]],"time":1421968352423}
{"patch":[[[[0,"January "],[1,"2"],[0,"2, 2014}"]],255,255,16,17]],"time":1421968351665}
{"patch":[[[[0,"nuary 22"],[1,"m"],[0,", 2014}\n"]],257,257,16,17]],"time":1421968350950}
{"patch":[[[[0,"ry 2"],[-1,"2m"],[0,", 20"]],260,260,10,8]],"time":1421968349449}
{"patch":[[[[0,"January "],[-1,"2"],[0,", 2014}\n"]],255,255,17,16]],"time":1421968348658}
{"patch":[[[[0,"{January"],[-1," "],[0,", 2014}\n"]],254,254,17,16]],"time":1421968345481}
{"patch":[[[[0,"e{Januar"],[-1,"y"],[0,", 2014}\n"]],253,253,17,16]],"time":1421968343184}
{"patch":[[[[0,"te{J"],[-1,"anuar"],[0,", 20"]],252,252,13,8]],"time":1421968342477}
{"patch":[[[[0,"}\n\\date{"],[-1,"J"],[1,"M"],[0,", 2014}\n"]],247,247,17,17]],"time":1421968341685}
{"patch":[[[[0,"\n\\date{M"],[1,"ay 1"],[0,", 2014}\n"]],248,248,16,20]],"time":1421968340931}
{"patch":[[[[0,"ate{May "],[1,"1"],[0,"1, 2014}"]],251,251,16,17]],"time":1421968340186}
{"patch":[[[[0," Stepany"],[-1,"an"],[0,"}\n\\date{"]],237,237,18,16]],"time":1421968327284}
{"patch":[[[[0," Ste"],[-1,"pany"],[0,"}\n\\d"]],237,237,12,8]],"time":1421968326533}
{"patch":[[[[0,"Samvel S"],[-1,"te"],[0,"}\n\\date{"]],231,231,18,16]],"time":1421968325817}
{"patch":[[[[0," Samvel "],[-1,"S"],[0,"}\n\\date{"]],230,230,17,16]],"time":1421968325046}
{"patch":[[[[0,"g, Samve"],[-1,"l "],[0,"}\n\\date{"]],228,228,18,16]],"time":1421968318924}
{"patch":[[[[0,"eng, Sam"],[-1,"ve"],[0,"}\n\\date{"]],226,226,18,16]],"time":1421968318082}
{"patch":[[[[0," Jeng, S"],[-1,"am"],[0,"}\n\\date{"]],224,224,18,16]],"time":1421968317336}
{"patch":[[[[0,"hn Jeng,"],[-1," S"],[0,"}\n\\date{"]],222,222,18,16]],"time":1421968316620}
{"patch":[[[[0,"ohn Jeng"],[-1,","],[0,"}\n\\date{"]],221,221,17,16]],"time":1421968315868}
{"patch":[[[[0,"{Proof}\n"],[1,"\n"],[0,"\\theorem"]],520,520,16,17]],"time":1421968304198}
{"patch":[[[[0,"heory.\n\n"],[1,"Trees look like this.\n\\includegraphics[scale=.3]{tree.png}\n\\newline\nIt is any simple connected graph without any cycles.\n\nIn a rooted tree, the top node is called the root.\nFor a node $v$, the nodes below it are called the descendants of $v$.\nThe nodes immediately below it are called its children.\nThe nodes above $v$ are called its ancestors.\nThe nodes immediately above $v$ are called the parents of $v$.\n\n"],[0,"\n\\subsec"]],3037,3037,16,425]],"time":1421968272490}
{"patch":[[[[0,"end{Def}"],[1,"Invariants are often used to prove correctness of some algorithm and our case is no exception."],[0,"\n\n\\subse"]],1411,1411,16,110]],"time":1421968261694}
{"patch":[[[[0,"end{Def}"],[1,"\n"],[0,"Invarian"]],1411,1411,16,17]],"time":1421968258175}
{"patch":[[[[0,"nd{Def}\n"],[1,"\n"],[0,"Invarian"]],1412,1412,16,17]],"time":1421968257118}
{"patch":[[[[0," x_0\\]\n\\end{Def}"],[1,"\nIn this sense we are bounding the growth rate of $f$ by the function $g$.\nWe will also commonly say that \\textit{f is ``O of g''} when the above is true.\nNote that typically we want to give a relatively ``tight'' bound on $f$.\nThat is to say, suppose $f(x) = x^3$.\n\\newline\nWhile it is true that $f(x)$ is $O(x^x)$, this is generally unhelpful and one would do better to say $f(x)$ is $O(x^3)$.\nOf course we do not always know if we have the ``tightest'' bound.\n\nBasic operations are considered $O(1)$.\nThat is, they take a constant time to execute.\nSome basic operations include arithmetic, checking conditionals, and assignmets."],[0,"\n\n\\begin{Def}\n\tA"]],1246,1246,32,663]],"time":1421968253445}
{"patch":[[[[0,"otions}\n"],[1,"Informally, we view a computer as something that can be given some commands which it will execute on some other information."],[0,"\n\n\\subse"]],944,944,16,140]],"time":1421968231275}
{"patch":[[[[0,"erence}\n"],[1,"In this section we present the necessary ideas used commonly in computer science to understand the analysis of our algorithms in later sections. \nThe section begins for those extremely unfamiliar with the field ending with more involved definitions.\nAny reader who is a fresh novice may need to jump between this section and the next for each to make sense.\nThose who have taken more than a few courses in computer science likely need not consult this section."],[0,"\n\n\\subse"]],908,908,16,476]],"time":1421968228615}
{"patch":[[[[0,"uction}\n"],[1,"Graph theory is the study of objects called graphs.\nGraphs have to main components: vertices and edges.\nA vertex is something like a destination or a place.\nEdges are like the paths between them.\nThus we can think of a road map of cities in a country as a graph.\nThe vertices would be the city names and the edges would be a road that connects them.\nOf course most cities have multiple paths connecting them, but suppose that there's just one.\nWe could then denote the travel time along these roads as distances (equally understood as costs or weights) of the edges.\n\\newline\nA fundamental problem in Graph theory is the single source, shortest path from a node s to any other node v.\nIn general on some graph G, the best we can do is $O(nm)$ where n is the number of vertices and m is the number of edges by Bellman-Ford [1].\nHowever, many graphs have some sort of structure to them.\nIn particular, we will examine planar graphs which have no crossing edges.\nThese graphs are quite common in our world since the earth is round.\nFor example, all road maps (with intersections as vertices) can be reduced to planar graphs (barring special instances of tunnels). \nDelaunay-triangulation diagrams can also be viewed as planar graphs (along with their dual, voronoi regions).\nAnd, though we will not touch on them here, many results of planar graphs can be generalized to graphs with some crossing edges and in some cases `many' crossing edges.\n\nTo build up to our main result, we will need to define some terminology in graph theory and discuss some properties of planar graphs. "],[0,"\n\n\\secti"]],869,869,16,1592]],"time":1421968222831}
{"patch":[[[[0," ABSTRAC"],[-1,"T"],[0," \n\\end{a"]],740,740,17,16]],"time":1421968215453}
{"patch":[[[[0," ABS"],[-1,"TRAC"],[0," \n\\e"]],740,740,12,8]],"time":1421968214664}
{"patch":[[[[0,"YAY "],[-1,"ABS"],[0," \n\\e"]],737,737,11,8]],"time":1421968213953}
{"patch":[[[[0,"\n\tYA"],[-1,"Y "],[0," \n\\e"]],735,735,10,8]],"time":1421968213164}
{"patch":[[[[0,"t}\n\t"],[-1,"Y"],[0,"A \n\\"]],733,733,9,8]],"time":1421968212448}
{"patch":[[[[0,"act}\n\tA "],[1,"graph G is planar if and only if it can be drawn on a plane (or equivically a sphere) without any of its edges crossing aside from meeting at vertices.\n\tIn this paper, we explore improvements in shortest path algorithms for planar graphs over general graphs. "],[0,"\n\\end{ab"]],731,731,16,275]],"time":1421968211665}